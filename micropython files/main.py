import machine
import dht
import utime
import framebuf
import ssd1306
import ds1307
import os
import sdcard
import network
import ubinascii
from umqtt.simple import MQTTClient

# Configuración del sensor DHT22
dht_pin = machine.Pin(4)
sensor = dht.DHT22(dht_pin)
led = machine.Pin(5, machine.Pin.OUT) #led rojo en d5


# Configuración de la pantalla OLED (I2C en GPIO 21 y 22)
i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21))

# Inicialización del RTC DS1307
rtc = ds1307.DS1307(i2c)
rtc.establecer_fecha(3, 4, 2025)
rtc.establecer_hora(1, 23, 0) 

# Inicialización de la microSD con la librería corregida
#spi = machine.SPI(1, baudrate=1000000, sck=machine.Pin(18), mosi=machine.Pin(23), miso=machine.Pin(19))
#cs = machine.Pin(5)  # Chip select
#sd = sdcard.SDCard(spi, cs)
#os.mount(sd, "/sd")
#sd_montada = False
#try:
 #   sd = sdcard.SDCard(spi, cs)
  #  vfs = os.VfsFat(sd)
   # os.mount(vfs, "/sd")
    #sd_montada = True
    #print("SD Montadad correctamente en /sd")
#except Exception as e:
 #   print("Error SD, usando memoria interna:",e)
  #  try:
   #     os.mkdir("/sd)
    #    print #







# Simula el montaje de la SD en Wokwi
try:
    os.mkdir("/sd")
except OSError:
    pass  # La carpeta ya existe

# Configuración WiFi
SSID = "Your SSID"
PASSWORD = "Your password"

# Configuración MQTT
MQTT_BROKER = "broker.emqx.io"
MQTT_CLIENT_ID = ubinascii.hexlify(machine.unique_id()).decode()
MQTT_PORT = 1883

# Nuevas Constantes de Tópicos
DEVICE_ID = "esp32_1"  #Esto debemos cambiarlo según cada placa
BASE_TOPIC = "sensores" # Raíz común para todos los dispositivos

# Subtópicos donde publicaremos
TOPIC_TEMP = f"{BASE_TOPIC}/{DEVICE_ID}/temperatura"
TOPIC_HUM  = f"{BASE_TOPIC}/{DEVICE_ID}/humedad"
TOPIC_LED  = f"{BASE_TOPIC}/{DEVICE_ID}/led"


# Verificar si el OLED está detectado
devices = i2c.scan()
if 0x3C not in devices:
    print("Error: Pantalla OLED no detectada en el bus I2C")
else:
    print("Pantalla OLED detectada correctamente.")

# Inicializar OLED (128x64)
oled = ssd1306.SSD1306_I2C(128, 64, i2c)

# Imagen monocromática en formato bytearray (debe ser de 1024 bytes para 128x64)
#emoji_bitmap = bytearray([0xFF] * 1024)  # Prueba con una imagen blanca para verificar
emoji_bitmap = bytearray([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0f, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x70, 0x71, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0x04, 0x18, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x69, 0x4c, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xe4, 0x44, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x08, 0x42, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x3f, 0x62, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x41, 0x9a, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1b, 0x7a, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x34, 0x3f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xec, 0x3f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe2, 0xc4, 0x3f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe9, 0x44, 0x7f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe2, 0x1a, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x94, 0x7e, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe4, 0x91, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe8, 0x88, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe8, 0x88, 0x20, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x84, 0x20, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x82, 0x20, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x81, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x81, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x81, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x86, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x49, 0xd3, 0xe6, 0x52, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xdb, 0x55, 0xd5, 0xc6, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xd7, 0x0d, 0xdd, 0x4d, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xd7, 0x55, 0xd5, 0x4f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xc9, 0x51, 0x04, 0x52, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xeb, 0x45, 0x15, 0xaf, 0x13, 0xb4, 0x9c, 0x47, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe3, 0x5c, 0xd5, 0x2f, 0x63, 0xa5, 0x9d, 0xb7, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xea, 0x9c, 0xd9, 0x2f, 0x67, 0x87, 0x9d, 0xb7, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xea, 0x25, 0x1c, 0x03, 0x13, 0x94, 0xac, 0x47, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])


# Crear el frame buffer para la imagen
emoji_fb = framebuf.FrameBuffer(emoji_bitmap, 128, 64, framebuf.MONO_HLSB)

# Mostrar la imagen antes de iniciar el bucle principal
oled.fill(0)  # Borra la pantalla
oled.blit(emoji_fb, 0, 0)  # Carga la imagen
oled.show()
utime.sleep(2)  # Espera 2 segundos para que la imagen sea visible antes de sobrescribir

# Conectar WiFi
def conectar_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(SSID, PASSWORD)

    while not wlan.isconnected():
        print("Conectando a WiFi...")
        utime.sleep(1)

    print("Conectado a WiFi:", wlan.ifconfig())


# Función para registrar datos
def registrar_datos(temp, hum):
    try:
        # Obtener fecha y hora reales del RTC
        fecha = rtc.obtener_fecha()
        hora = rtc.obtener_hora()

        # Guardar en la microSD
        with open("/sd/datalog.csv", "a") as f:
            f.write(f"{fecha} {hora}, {temp:.1f}, {hum:.1f}\n")


        # Leer y mostrar contenido en la consola
        print("\n--- Contenido de datalog.csv ---")
        with open("/sd/datalog.csv", "r") as f:
            for line in f:
                print(line)

    except Exception as e:
        print("Error al guardar datos!!")


# Función para obtener datos del sensor DHT22
def obtener_temperatura():
    sensor.measure()
    temp = sensor.temperature()  # °C
    hum = sensor.humidity()  # %
    return temp, hum

# Función para mostrar la temperatura, humedad y el emoji de estado
def mostrar_emoji(temp, hum):
    oled.fill(0)  # Borra la pantalla antes de escribir texto
    oled.text("Temp: {:.1f}C".format(temp), 0, 0)
    oled.text("Hum: {:.1f}%".format(hum), 0, 10)

    # Mostrar un estado en función de la temperatura
    if temp < 15:
        oled.text("FRIO [*]", 30, 30)  # Frío 
    elif temp >= 15 and temp <= 30:
        oled.text("NORMAL :)", 30, 30)  # Normal 
    else:
        oled.text("CALOR [!]", 30, 30)  # Calor 

    oled.show()


# Función para publicar datos en MQTT
def publicar_mqtt(temp, hum):
    if temp is None or hum is None:
        print("No hay datos válidos para enviar.")
        return

    try:
        mensajes = f'{{"temperatura": {temp:.1f}, "humedad": {hum:.1f}}}'
        # Publicamos en cada sub-tópico
        mqtt_client.publish(TOPIC_TEMP, mensajes)
        mqtt_client.publish(TOPIC_HUM, mensajes)
        print(f"Datos enviados MQTT: {mensajes} en {TOPIC_TEMP} y {TOPIC_HUM}")
    except Exception as e:
        print("Error al enviar datos MQTT:", e)
        
        
def mqtt_callback(topic, msg):
    topic = topic.decode() # ejemplo: "sensores/esp32_1/led"
    mensaje = msg.decode('utf-8').strip().lower()
    print(f"Mensaje recibido en {topic}: {mensaje}")
    
    # Extraemos parte del tópico
    _, device_id, action =  topic.split("/")
    if device_id != DEVICE_ID:
        # Ignoramos comandos dirigidos a otros disps
        return
            
    # Solo procesamos acción si es led
    if action == "led":
        if mensaje == 'on':
            led.value(1)
            print("LED Encendido via MQTT")
        elif mensaje == 'off':
            led.value(0)
            print("LED Apagado via MQTT")
    

# Conectar a WiFi antes de iniciar MQTT
conectar_wifi()

# Inicializar cliente MQTT
mqtt_client = MQTTClient(MQTT_CLIENT_ID, MQTT_BROKER, port=MQTT_PORT)
mqtt_client.set_callback(mqtt_callback)
mqtt_client.connect()

#Nos suscribimos al wildcard que nos interesa para el LED
mqtt_client.subscribe(f"{BASE_TOPIC}/+/led")
print(f"Conectado al broker MQTT {MQTT_BROKER} y suscrito a {BASE_TOPIC}/+/led")


# Bucle principal
while True:
    try:
        temperatura, humedad = obtener_temperatura()
        mostrar_emoji(temperatura, humedad)
        registrar_datos(temperatura,humedad)
        #Procesar los mensajes MQTT entrantes para controlar el led
        mqtt_client.check_msg()
        utime.sleep(2)  # Espera 2 segundos antes de actualizar
        if temperatura is not None and humedad is not None:
            print(f" Temp: {temperatura:.1f}°C | Hum: {humedad:.1f}%")
            publicar_mqtt(temperatura, humedad)
    except OSError as e:
        oled.fill(0)
        oled.text("Error Sensor!", 20, 20)
        oled.show()
        utime.sleep(2)

    
    